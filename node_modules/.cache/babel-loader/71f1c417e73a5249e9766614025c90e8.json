{"ast":null,"code":"import TemplateService from './services/template-service';\nimport getter from './utils/getter';\nimport map from './utils/map';\n\nfunction defaultGroupHeaderTemplate(data) {\n  return data.title + \": \" + data.value;\n}\n\nfunction createArray(length, callback) {\n  var result = [];\n\n  for (var idx = 0; idx < length; idx++) {\n    result.push(callback(idx));\n  }\n\n  return result;\n}\n\nvar ExcelExporter = function ExcelExporter(options) {\n  options.columns = this._trimColumns(options.columns || []);\n  this.allColumns = map(this._leafColumns(options.columns || []), this._prepareColumn);\n  this.columns = this.allColumns.filter(function (column) {\n    return !column.hidden;\n  });\n  this.options = options;\n  this.data = options.data || [];\n  this.aggregates = options.aggregates || {};\n  this.groups = [].concat(options.groups || []);\n  this.hierarchy = options.hierarchy;\n};\n\nExcelExporter.prototype.workbook = function workbook() {\n  var workbook = {\n    sheets: [{\n      columns: this._columns(),\n      rows: this.hierarchy ? this._hierarchyRows() : this._rows(),\n      freezePane: this._freezePane(),\n      filter: this._filter()\n    }]\n  };\n  return workbook;\n};\n\nExcelExporter.prototype._trimColumns = function _trimColumns(columns) {\n  var this$1 = this;\n  return columns.filter(function (column) {\n    var result = Boolean(column.field);\n\n    if (!result && column.columns) {\n      result = this$1._trimColumns(column.columns).length > 0;\n    }\n\n    return result;\n  });\n};\n\nExcelExporter.prototype._leafColumns = function _leafColumns(columns) {\n  var this$1 = this;\n  var result = [];\n\n  for (var idx = 0; idx < columns.length; idx++) {\n    if (!columns[idx].columns) {\n      result.push(columns[idx]);\n    } else {\n      result = result.concat(this$1._leafColumns(columns[idx].columns));\n    }\n  }\n\n  return result;\n};\n\nExcelExporter.prototype._prepareColumn = function _prepareColumn(column) {\n  if (!column.field) {\n    return null;\n  }\n\n  var value = function value(dataItem) {\n    return getter(column.field, true)(dataItem);\n  };\n\n  var values = null;\n\n  if (column.values) {\n    values = {};\n    column.values.forEach(function (item) {\n      values[item.value] = item.text;\n    });\n\n    value = function value(dataItem) {\n      return values[getter(column.field, true)(dataItem)];\n    };\n  }\n\n  return Object.assign({}, column, {\n    value: value,\n    values: values,\n    groupHeaderTemplate: column.groupHeaderTemplate ? TemplateService.compile(column.groupHeaderTemplate) : defaultGroupHeaderTemplate,\n    groupFooterTemplate: column.groupFooterTemplate ? TemplateService.compile(column.groupFooterTemplate) : null,\n    footerTemplate: column.footerTemplate ? TemplateService.compile(column.footerTemplate) : null\n  });\n};\n\nExcelExporter.prototype._filter = function _filter() {\n  if (!this.options.filterable) {\n    return null;\n  }\n\n  var depth = this._depth();\n\n  return {\n    from: depth,\n    to: depth + this.columns.length - 1\n  };\n};\n\nExcelExporter.prototype._createPaddingCells = function _createPaddingCells(length) {\n  var this$1 = this;\n  return createArray(length, function () {\n    return Object.assign({\n      background: \"#dfdfdf\",\n      color: \"#333\"\n    }, this$1.options.paddingCellOptions);\n  });\n};\n\nExcelExporter.prototype._dataRow = function _dataRow(dataItem, level, depth) {\n  var this$1 = this;\n\n  var cells = this._createPaddingCells(level); // grouped\n\n\n  if (depth && dataItem.items) {\n    var column = this.allColumns.filter(function (column) {\n      return column.field === dataItem.field;\n    })[0];\n    var title = column && column.title ? column.title : dataItem.field;\n    var template = column ? column.groupHeaderTemplate : null;\n    var group = Object.assign({\n      title: title,\n      field: dataItem.field,\n      value: column && column.values ? column.values[dataItem.value] : dataItem.value,\n      aggregates: dataItem.aggregates,\n      items: dataItem.items\n    }, dataItem.aggregates[dataItem.field]);\n    var value = title + \": \" + dataItem.value;\n\n    if (template) {\n      value = template(group);\n    }\n\n    cells.push(Object.assign({\n      value: value,\n      background: \"#dfdfdf\",\n      color: \"#333\",\n      colSpan: this.columns.length + depth - level\n    }, (column || {}).groupHeaderCellOptions));\n\n    var rows = this._dataRows(dataItem.items, level + 1);\n\n    rows.unshift({\n      type: \"group-header\",\n      cells: cells,\n      level: this.options.collapsible ? level : null\n    });\n    return rows.concat(this._footer(dataItem, level));\n  }\n\n  var dataCells = [];\n\n  for (var cellIdx = 0; cellIdx < this.columns.length; cellIdx++) {\n    dataCells[cellIdx] = this$1._cell(dataItem, this$1.columns[cellIdx]);\n  }\n\n  if (this.hierarchy) {\n    dataCells[0].colSpan = depth - level + 1;\n  }\n\n  return [{\n    type: \"data\",\n    cells: cells.concat(dataCells),\n    level: this.options.collapsible ? level : null\n  }];\n};\n\nExcelExporter.prototype._dataRows = function _dataRows(dataItems, level) {\n  var this$1 = this;\n\n  var depth = this._depth();\n\n  var rows = [];\n\n  for (var idx = 0; idx < dataItems.length; idx++) {\n    rows.push.apply(rows, this$1._dataRow(dataItems[idx], level, depth));\n  }\n\n  return rows;\n};\n\nExcelExporter.prototype._hierarchyRows = function _hierarchyRows() {\n  var this$1 = this;\n\n  var depth = this._depth();\n\n  var data = this.data;\n  var itemLevel = this.hierarchy.itemLevel;\n\n  var hasFooter = this._hasFooterTemplate();\n\n  var rows = [];\n  var parents = [];\n  var previousLevel = 0;\n  var previousItemId;\n\n  for (var idx = 0; idx < data.length; idx++) {\n    var item = data[idx];\n    var level = itemLevel(item);\n\n    if (hasFooter) {\n      if (level > previousLevel) {\n        parents.push({\n          id: previousItemId,\n          level: previousLevel\n        });\n      } else if (level < previousLevel) {\n        rows.push.apply(rows, this$1._hierarchyFooterRows(parents, level, depth));\n      }\n\n      previousLevel = level;\n      previousItemId = item.id;\n    }\n\n    rows.push.apply(rows, this$1._dataRow(item, level + 1, depth));\n  }\n\n  if (hasFooter) {\n    rows.push.apply(rows, this._hierarchyFooterRows(parents, 0, depth));\n    var rootAggregate = data.length ? this.aggregates[data[0].parentId] : {};\n    rows.push(this._hierarchyFooter(rootAggregate, 0, depth));\n  }\n\n  this._prependHeaderRows(rows);\n\n  return rows;\n};\n\nExcelExporter.prototype._hierarchyFooterRows = function _hierarchyFooterRows(parents, currentLevel, depth) {\n  var this$1 = this;\n  var rows = [];\n\n  while (parents.length && parents[parents.length - 1].level >= currentLevel) {\n    var parent = parents.pop();\n    rows.push(this$1._hierarchyFooter(this$1.aggregates[parent.id], parent.level + 1, depth));\n  }\n\n  return rows;\n};\n\nExcelExporter.prototype._hasFooterTemplate = function _hasFooterTemplate() {\n  var columns = this.columns;\n\n  for (var idx = 0; idx < columns.length; idx++) {\n    if (columns[idx].footerTemplate) {\n      return true;\n    }\n  }\n};\n\nExcelExporter.prototype._hierarchyFooter = function _hierarchyFooter(aggregates, level, depth) {\n  var cells = this.columns.map(function (column, index) {\n    var colSpan = index ? 1 : depth - level + 1;\n\n    if (column.footerTemplate) {\n      return Object.assign({\n        background: \"#dfdfdf\",\n        color: \"#333\",\n        colSpan: colSpan,\n        value: column.footerTemplate(Object.assign({}, (aggregates || {})[column.field]))\n      }, column.footerCellOptions);\n    }\n\n    return Object.assign({\n      background: \"#dfdfdf\",\n      color: \"#333\",\n      colSpan: colSpan\n    }, column.footerCellOptions);\n  });\n  return {\n    type: \"footer\",\n    cells: this._createPaddingCells(level).concat(cells)\n  };\n};\n\nExcelExporter.prototype._footer = function _footer(dataItem, level) {\n  var rows = [];\n  var footer = this.columns.some(function (column) {\n    return column.groupFooterTemplate;\n  });\n  var templateData, group;\n\n  if (footer) {\n    group = {\n      group: {\n        items: dataItem.items,\n        field: dataItem.field,\n        value: dataItem.value\n      }\n    };\n    templateData = {};\n    Object.keys(dataItem.aggregates).forEach(function (key) {\n      templateData[key] = Object.assign({}, dataItem.aggregates[key], group);\n    });\n  }\n\n  var cells = this.columns.map(function (column) {\n    if (column.groupFooterTemplate) {\n      var data = Object.assign({}, templateData, dataItem.aggregates[column.field], group);\n      return Object.assign({\n        background: \"#dfdfdf\",\n        color: \"#333\",\n        value: column.groupFooterTemplate(data)\n      }, column.groupFooterCellOptions);\n    }\n\n    return Object.assign({\n      background: \"#dfdfdf\",\n      color: \"#333\"\n    }, column.groupFooterCellOptions);\n  });\n\n  if (footer) {\n    rows.push({\n      type: \"group-footer\",\n      cells: this._createPaddingCells(this.groups.length).concat(cells),\n      level: this.options.collapsible ? level : null\n    });\n  }\n\n  return rows;\n};\n\nExcelExporter.prototype._isColumnVisible = function _isColumnVisible(column) {\n  return this._visibleColumns([column]).length > 0 && (column.field || column.columns);\n};\n\nExcelExporter.prototype._visibleColumns = function _visibleColumns(columns) {\n  var this$1 = this;\n  return columns.filter(function (column) {\n    var result = !column.hidden;\n\n    if (result && column.columns) {\n      result = this$1._visibleColumns(column.columns).length > 0;\n    }\n\n    return result;\n  });\n};\n\nExcelExporter.prototype._headerRow = function _headerRow(row, groups) {\n  var this$1 = this;\n  var headers = row.cells.map(function (cell) {\n    return Object.assign(cell, {\n      colSpan: cell.colSpan > 1 ? cell.colSpan : 1,\n      rowSpan: row.rowSpan > 1 && !cell.colSpan ? row.rowSpan : 1\n    });\n  });\n\n  if (this.hierarchy) {\n    headers[0].colSpan = this._depth() + 1;\n  }\n\n  return {\n    type: \"header\",\n    cells: createArray(groups.length, function () {\n      return Object.assign({\n        background: \"#7a7a7a\",\n        color: \"#fff\"\n      }, this$1.options.headerPaddingCellOptions);\n    }).concat(headers)\n  };\n};\n\nExcelExporter.prototype._prependHeaderRows = function _prependHeaderRows(rows) {\n  var this$1 = this;\n  var groups = this.groups;\n  var headerRows = [{\n    rowSpan: 1,\n    cells: [],\n    index: 0\n  }];\n\n  this._prepareHeaderRows(headerRows, this.options.columns);\n\n  for (var idx = headerRows.length - 1; idx >= 0; idx--) {\n    rows.unshift(this$1._headerRow(headerRows[idx], groups));\n  }\n};\n\nExcelExporter.prototype._prepareHeaderRows = function _prepareHeaderRows(rows, columns, parentCell, parentRow) {\n  var this$1 = this;\n  var row = parentRow || rows[rows.length - 1];\n  var childRow = rows[row.index + 1];\n  var totalColSpan = 0;\n\n  for (var idx = 0; idx < columns.length; idx++) {\n    var column = columns[idx];\n\n    if (this$1._isColumnVisible(column)) {\n      var cell = Object.assign({\n        background: \"#7a7a7a\",\n        color: \"#fff\",\n        value: column.title || column.field,\n        colSpan: 0\n      }, column.headerCellOptions);\n      row.cells.push(cell);\n\n      if (column.columns && column.columns.length) {\n        if (!childRow) {\n          childRow = {\n            rowSpan: 0,\n            cells: [],\n            index: rows.length\n          };\n          rows.push(childRow);\n        }\n\n        cell.colSpan = this$1._trimColumns(this$1._visibleColumns(column.columns)).length;\n\n        this$1._prepareHeaderRows(rows, column.columns, cell, childRow);\n\n        totalColSpan += cell.colSpan - 1;\n        row.rowSpan = rows.length - row.index;\n      }\n    }\n  }\n\n  if (parentCell) {\n    parentCell.colSpan += totalColSpan;\n  }\n};\n\nExcelExporter.prototype._rows = function _rows() {\n  var this$1 = this;\n\n  var rows = this._dataRows(this.data, 0);\n\n  if (this.columns.length) {\n    this._prependHeaderRows(rows);\n\n    var footer = false;\n    var cells = this.columns.map(function (column) {\n      if (column.footerTemplate) {\n        footer = true;\n        return Object.assign({\n          background: \"#dfdfdf\",\n          color: \"#333\",\n          value: column.footerTemplate(Object.assign({}, this$1.aggregates, this$1.aggregates[column.field]))\n        }, column.footerCellOptions);\n      }\n\n      return Object.assign({\n        background: \"#dfdfdf\",\n        color: \"#333\"\n      }, column.footerCellOptions);\n    });\n\n    if (footer) {\n      rows.push({\n        type: \"footer\",\n        cells: this._createPaddingCells(this.groups.length).concat(cells)\n      });\n    }\n  }\n\n  return rows;\n};\n\nExcelExporter.prototype._headerDepth = function _headerDepth(columns) {\n  var this$1 = this;\n  var result = 1;\n  var max = 0;\n\n  for (var idx = 0; idx < columns.length; idx++) {\n    if (columns[idx].columns) {\n      var temp = this$1._headerDepth(columns[idx].columns);\n\n      if (temp > max) {\n        max = temp;\n      }\n    }\n  }\n\n  return result + max;\n};\n\nExcelExporter.prototype._freezePane = function _freezePane() {\n  var columns = this._visibleColumns(this.options.columns || []);\n\n  var colSplit = this._visibleColumns(this._trimColumns(this._leafColumns(columns.filter(function (column) {\n    return column.locked;\n  })))).length;\n\n  return {\n    rowSplit: this._headerDepth(columns),\n    colSplit: colSplit ? colSplit + this.groups.length : 0\n  };\n};\n\nExcelExporter.prototype._cell = function _cell(dataItem, column) {\n  return Object.assign({\n    value: column.value(dataItem)\n  }, column.cellOptions);\n};\n\nExcelExporter.prototype._depth = function _depth() {\n  var depth = 0;\n\n  if (this.hierarchy) {\n    depth = this.hierarchy.depth;\n  } else {\n    depth = this.groups.length;\n  }\n\n  return depth;\n};\n\nExcelExporter.prototype._columns = function _columns() {\n  var depth = this._depth();\n\n  var columns = createArray(depth, function () {\n    return {\n      width: 20\n    };\n  });\n  return columns.concat(this.columns.map(function (column) {\n    return {\n      width: parseInt(column.width, 10),\n      autoWidth: column.width ? false : true\n    };\n  }));\n};\n\nexport default ExcelExporter;","map":null,"metadata":{},"sourceType":"module"}