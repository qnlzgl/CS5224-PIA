{"ast":null,"code":"/**\n * Copyright 2015 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar format = require('./utilities/format');\n\nvar comparators = require('./utilities/comparators');\n\nvar CIRCUMPLEX_ORDER_OF_PERSONALITY_TRAITS = 'EANOC';\n\nvar TextSummaryImpl = function () {\n  function TextSummaryImpl(options, I18nData, PersonalityProfile) {\n    _classCallCheck(this, TextSummaryImpl);\n\n    this._version = options.version;\n    this.I18nData = I18nData;\n    this.PersonalityProfile = PersonalityProfile;\n    this.setLocale(options.locale);\n  }\n\n  _createClass(TextSummaryImpl, [{\n    key: 'setLocale',\n    value: function setLocale(locale) {\n      if (this._locale !== locale) {\n        this._locale = locale;\n        var i18n = new this.I18nData(locale);\n        var dictionary = i18n.data();\n        var translatorFactory = i18n.translatorFactory();\n        this._translator = translatorFactory.createTranslator(dictionary.phrases);\n        this.big5Data = dictionary.big5;\n        this.circumplexData = dictionary.traits;\n        this.facetsData = dictionary.facets;\n        this.valuesData = dictionary.values;\n        this.needsData = dictionary.needs;\n      }\n    } //getSummary(profile) {\n\n  }, {\n    key: 'getSummary',\n    value: function getSummary(profile) {\n      var personalityProfile = new this.PersonalityProfile(profile);\n      return this.assemble(personalityProfile).map(function (paragraph) {\n        return paragraph.join(' ');\n      }).join('\\n');\n    } //assemble(tree) {\n\n  }, {\n    key: 'assemble',\n    value: function assemble(profile) {\n      return [this.assembleTraits(profile.traits()), this.assembleFacets(profile.traits()), this.assembleNeeds(profile.needs()), this.assembleValues(profile.values())];\n    } //assembleTraits(personalityTree) {\n\n  }, {\n    key: 'assembleTraits',\n    value: function assembleTraits(traits) {\n      var sentences = [],\n          big5elements = [],\n          relevantBig5,\n          adj1,\n          adj2,\n          adj3; // Sort the Big 5 based on how extreme the number is.\n\n      traits.forEach(function (p) {\n        big5elements.push({\n          id: p.id,\n          percentage: p.score\n        });\n      });\n      big5elements.sort(comparators.compareByRelevance); // Remove all traits with percentage values between 32% and 68%, as it's inside the common people.\n\n      relevantBig5 = big5elements.filter(function (item) {\n        return Math.abs(0.5 - item.percentage) > 0.18;\n      });\n\n      if (relevantBig5.length < 2) {\n        // Even if no Big 5 attribute is interesting, you get 1 adjective.\n        relevantBig5 = [big5elements[0], big5elements[1]];\n      }\n\n      adj1 = relevantBig5.length >= 2 ? this.getCircumplexAdjective(relevantBig5[0], relevantBig5[1], 0) : null;\n      adj2 = relevantBig5.length >= 3 ? this.getCircumplexAdjective(relevantBig5[1], relevantBig5[2], 1) : null;\n      adj3 = relevantBig5.length >= 4 ? this.getCircumplexAdjective(relevantBig5[2], relevantBig5[3], 2) : null; // Generate sentences summarizing personality traits composed of cross trait phrases\n\n      switch (relevantBig5.length) {\n        case 2:\n          sentences.push(format(this._translator('You are %s'), adj1) + '.');\n          break;\n\n        case 3:\n          sentences.push(format(this._translator('You are %s and %s'), adj1, adj2) + '.');\n          break;\n\n        case 4:\n        case 5:\n          sentences.push(format(this._translator('You are %s, %s and %s'), adj1, adj2, adj3) + '.');\n          break;\n      }\n\n      return sentences;\n    } //assembleFacets(personalityTree) {\n\n  }, {\n    key: 'assembleFacets',\n    value: function assembleFacets(traits) {\n      var sentences = [],\n          facetElements = [],\n          info,\n          i; // Assemble the full list of facets and sort them based on how extreme\n      // is the number.\n\n      traits.forEach(function (p) {\n        p.facets.forEach(function (f) {\n          facetElements.push({\n            id: f.id,\n            percentage: f.score,\n            parent: p\n          });\n        });\n      });\n      facetElements.sort(comparators.compareByRelevance);\n      info = this.getFacetInfo(facetElements[0]);\n      sentences.push(format(this._translator('You are %s'), info.term) + ': ' + info.description + '.');\n      info = this.getFacetInfo(facetElements[1]);\n      sentences.push(format(this._translator('You are %s'), info.term) + ': ' + info.description + '.'); // If all the facets correspond to the same feature, continue until a\n      // different parent feature is found.\n\n      i = 2;\n\n      if (facetElements[0].parent === facetElements[1].parent) {\n        while (facetElements[0].parent === facetElements[i].parent) {\n          i += 1;\n        }\n      }\n\n      info = this.getFacetInfo(facetElements[i]);\n      sentences.push(format(this._translator('And you are %s'), info.term) + ': ' + info.description + '.');\n      return sentences;\n    } //assembleNeeds(needsTree) {\n\n  }, {\n    key: 'assembleNeeds',\n    value: function assembleNeeds(needs) {\n      var sentences = [],\n          needsList = [],\n          word,\n          sentence;\n      needs.forEach(function (n) {\n        needsList.push({\n          id: n.id,\n          percentage: n.score\n        });\n      });\n      needsList.sort(comparators.compareByValue); // Get the words required.\n\n      var need = needsList[0];\n      word = this.needsData[need.id][0]; // Form the right sentence for the single need.\n\n      switch (this.intervalFor(needsList[0].percentage)) {\n        case 0:\n          sentence = this._translator('Experiences that make you feel high %s are generally unappealing to you');\n          break;\n\n        case 1:\n          sentence = this._translator('Experiences that give a sense of %s hold some appeal to you');\n          break;\n\n        case 2:\n          sentence = this._translator('You are motivated to seek out experiences that provide a strong feeling of %s');\n          break;\n\n        case 3:\n          sentence = this._translator('Your choices are driven by a desire for %s');\n          break;\n      }\n\n      sentence = format(sentence, word).concat('.');\n      sentences.push(sentence);\n      return sentences;\n    }\n  }, {\n    key: 'assembleValues',\n    value: function assembleValues(values) {\n      var sentences = [],\n          valuesList = [],\n          info1,\n          info2,\n          sentence,\n          valuesInfo,\n          i,\n          term1,\n          term2;\n      values.forEach(function (v) {\n        valuesList.push({\n          id: v.id,\n          percentage: v.score\n        });\n      });\n      valuesList.sort(comparators.compareByRelevance); // Get all the text and data required.\n\n      info1 = this.getValueInfo(valuesList[0]);\n      info2 = this.getValueInfo(valuesList[1]);\n\n      if (this.intervalFor(valuesList[0].percentage) === this.intervalFor(valuesList[1].percentage)) {\n        // Assemble the first 'both' sentence.\n        term1 = info1.term;\n        term2 = info2.term;\n\n        switch (this.intervalFor(valuesList[0].percentage)) {\n          case 0:\n            sentence = format(this._translator('You are relatively unconcerned with both %s and %s'), term1, term2) + '.';\n            break;\n\n          case 1:\n            sentence = format(this._translator('You don\\'t find either %s or %s to be particularly motivating for you'), term1, term2) + '.';\n            break;\n\n          case 2:\n            sentence = format(this._translator('You value both %s and %s a bit'), term1, term2) + '.';\n            break;\n\n          case 3:\n            sentence = format(this._translator('You consider both %s and %s to guide a large part of what you do'), term1, term2) + '.';\n            break;\n        }\n\n        sentences.push(sentence); // Assemble the final strings in the correct format.\n\n        sentences.push(info1.description + '.');\n        sentences.push(format(this._translator('And %s'), info2.description.toLowerCase()) + '.');\n      } else {\n        valuesInfo = [info1, info2];\n\n        for (i = 0; i < valuesInfo.length; i += 1) {\n          // Process it this way because the code is the same.\n          switch (this.intervalFor(valuesList[i].percentage)) {\n            case 0:\n              sentence = format(this._translator('You are relatively unconcerned with %s'), valuesInfo[i].term);\n              break;\n\n            case 1:\n              sentence = format(this._translator('You don\\'t find %s to be particularly motivating for you'), valuesInfo[i].term);\n              break;\n\n            case 2:\n              sentence = format(this._translator('You value %s a bit more'), valuesInfo[i].term);\n              break;\n\n            case 3:\n              sentence = format(this._translator('You consider %s to guide a large part of what you do'), valuesInfo[i].term);\n              break;\n          }\n\n          sentence = sentence.concat(': ').concat(valuesInfo[i].description.toLowerCase()).concat('.');\n          sentences.push(sentence);\n        }\n      }\n\n      return sentences;\n    }\n    /**\n    *  getCircumplexAdjective generates a qualified cross trait phrase given two personality traits, p1 and p2\n    *  p1 and p2: personality traits of the form {\"id\":<id>,\"percentage\":<percentage>}\n    *  order: determines which qualifier to use for the cross trait adjective\n    *      e.g., terms that are viewed negatively in Western culture are qualified with 'a bit' or 'somewhat'\n    *         0: 'a bit'\n    *         1: 'somewhat'\n    *         2: 'can be perceived as'\n    *  Returns the qualified cross trait adjective phrase for p1 and p2.\n    */\n\n  }, {\n    key: 'getCircumplexAdjective',\n    value: function getCircumplexAdjective(p1, p2, order) {\n      var version = this._version;\n      var ordered = [p1, p2].sort(function (o1, o2) {\n        var i1, i2;\n\n        if (version === 'v3') {\n          i1 = CIRCUMPLEX_ORDER_OF_PERSONALITY_TRAITS.indexOf(o1.id.replace('big5_', '').charAt(0).toUpperCase());\n          i2 = CIRCUMPLEX_ORDER_OF_PERSONALITY_TRAITS.indexOf(o2.id.replace('big5_', '').charAt(0).toUpperCase());\n        } else {\n          i1 = CIRCUMPLEX_ORDER_OF_PERSONALITY_TRAITS.indexOf(o1.id.charAt(0));\n          i2 = CIRCUMPLEX_ORDER_OF_PERSONALITY_TRAITS.indexOf(o2.id.charAt(0));\n        }\n\n        return i1 < i2 ? -1 : 1;\n      }); // Assemble the identifier as the JSON file stored it.\n\n      var identifier = ordered[0].id.concat(ordered[0].percentage > 0.5 ? '_plus_' : '_minus_').concat(ordered[1].id).concat(ordered[1].percentage > 0.5 ? '_plus' : '_minus');\n      var traitMult = this.circumplexData[identifier][0];\n      var sentence = '%s';\n\n      if (traitMult.perceived_negatively) {\n        switch (order) {\n          case 0:\n            sentence = this._translator('a bit %s');\n            break;\n\n          case 1:\n            sentence = this._translator('somewhat %s');\n            break;\n\n          case 2:\n            sentence = this._translator('can be perceived as %s');\n            break;\n        }\n      }\n\n      return format(sentence, traitMult.word);\n    }\n  }, {\n    key: 'getValueInfo',\n    value: function getValueInfo(v) {\n      return {\n        name: v.id,\n        term: this.valuesData[v.id][0].Term.toLowerCase(),\n        description: v.percentage > 0.5 ? this.valuesData[v.id][0].HighDescription : this.valuesData[v.id][0].LowDescription\n      };\n    }\n  }, {\n    key: 'getFacetInfo',\n    value: function getFacetInfo(f) {\n      return {\n        name: f.id,\n        term: f.percentage > 0.5 ? this.facetsData[f.id].HighTerm.toLowerCase() : this.facetsData[f.id].LowTerm.toLowerCase(),\n        description: f.percentage > 0.5 ? this.facetsData[f.id].HighDescription.toLowerCase() : this.facetsData[f.id].LowDescription.toLowerCase()\n      };\n    }\n  }, {\n    key: 'getFacet',\n    value: function getFacet(id) {\n      var facet = this.facetsData[id];\n\n      if (facet) {\n        return Object.assign({}, facet);\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: 'getTrait',\n    value: function getTrait(id) {\n      var trait = this.big5Data[id];\n\n      if (trait) {\n        return Object.assign({}, trait);\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: 'intervalFor',\n    value: function intervalFor(p) {\n      return Math.min(Math.floor(p * 4), 3);\n    }\n  }]);\n\n  return TextSummaryImpl;\n}();\n\nmodule.exports = TextSummaryImpl;","map":null,"metadata":{},"sourceType":"script"}